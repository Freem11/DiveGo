{
  "version": 3,
  "sources": ["../../kdbush/src/sort.js", "../../kdbush/src/range.js", "../../kdbush/src/within.js", "../../kdbush/src/index.js", "../../supercluster/index.js", "../../use-deep-compare-effect/dist/use-deep-compare-effect.esm.js", "../../dequal/dist/index.mjs", "../../use-supercluster/src/index.tsx", "dep:use-supercluster"],
  "sourcesContent": ["\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n", "\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n", "\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n", "\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n", "\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n", "import * as React from 'react';\nimport { dequal } from 'dequal';\n\nfunction checkDeps(deps) {\n  if (!deps || !deps.length) {\n    throw new Error('useDeepCompareEffect should not be used with no dependencies. Use React.useEffect instead.');\n  }\n\n  if (deps.every(isPrimitive)) {\n    throw new Error('useDeepCompareEffect should not be used with dependencies that are all primitive values. Use React.useEffect instead.');\n  }\n}\n\nfunction isPrimitive(val) {\n  return val == null || /^[sbn]/.test(typeof val);\n}\n/**\n * @param value the value to be memoized (usually a dependency list)\n * @returns a momoized version of the value as long as it remains deeply equal\n */\n\n\nfunction useDeepCompareMemoize(value) {\n  var ref = React.useRef(value);\n  var signalRef = React.useRef(0);\n\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n    signalRef.current += 1;\n  } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  return React.useMemo(function () {\n    return ref.current;\n  }, [signalRef.current]);\n}\n\nfunction useDeepCompareEffect(callback, dependencies) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkDeps(dependencies);\n  } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  return React.useEffect(callback, useDeepCompareMemoize(dependencies));\n}\n\nfunction useDeepCompareEffectNoCheck(callback, dependencies) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useEffect(callback, useDeepCompareMemoize(dependencies));\n}\n\nexport { useDeepCompareEffect as default, useDeepCompareEffectNoCheck, useDeepCompareMemoize };\n", "var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "import { useRef, useState } from \"react\";\nimport Supercluster from \"supercluster\";\nimport { BBox, GeoJsonProperties } from \"geojson\";\nimport { useDeepCompareEffectNoCheck } from \"use-deep-compare-effect\";\nimport { dequal } from \"dequal\";\n\nexport interface UseSuperclusterArgument<P, C> {\n  points: Array<Supercluster.PointFeature<P>>;\n  bounds?: BBox;\n  zoom: number;\n  options?: Supercluster.Options<P, C>;\n}\n\nconst useSupercluster = <\n  P extends GeoJsonProperties = Supercluster.AnyProps,\n  C extends GeoJsonProperties = Supercluster.AnyProps\n>({\n  points,\n  bounds,\n  zoom,\n  options\n}: UseSuperclusterArgument<P, C>) => {\n  const superclusterRef = useRef<Supercluster<P, C>>();\n  const pointsRef = useRef<Array<Supercluster.PointFeature<P>>>();\n  const [clusters, setClusters] = useState<\n    Array<Supercluster.ClusterFeature<C> | Supercluster.PointFeature<P>>\n  >([]);\n  const zoomInt = Math.round(zoom);\n\n  useDeepCompareEffectNoCheck(() => {\n    if (\n      !superclusterRef.current ||\n      !dequal(pointsRef.current, points) ||\n      !dequal(\n        (superclusterRef.current as typeof superclusterRef.current & {\n          options: typeof options;\n        }).options,\n        options\n      )\n    ) {\n      superclusterRef.current = new Supercluster(options);\n      superclusterRef.current.load(points);\n    }\n\n    if (bounds) {\n      setClusters(superclusterRef.current.getClusters(bounds, zoomInt));\n    }\n\n    pointsRef.current = points;\n  }, [points, bounds, zoomInt, options]);\n\n  return { clusters, supercluster: superclusterRef.current };\n};\n\nexport default useSupercluster;\n", "import d from \"./node_modules/use-supercluster/dist/use-supercluster.esm.js\";export default d;"],
  "mappings": "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",
  "names": []
}
